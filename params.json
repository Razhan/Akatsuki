{"name":"Akatsuki","tagline":"Akatsuki is an Android library that handles state restoration via annotations.","body":"Akatsuki\r\n============\r\n\r\n[![Android Arsenal](https://img.shields.io/badge/Android%20Arsenal-Akatsuki-green.svg?style=flat)](https://android-arsenal.com/details/1/2230)\r\n[![Build Status](https://travis-ci.org/tom91136/Akatsuki.svg)](https://travis-ci.org/tom91136/Akatsuki)\r\n\r\n**This library is complete and functional but I would like to make sure everything works so no artifacts yet!**\r\n\r\nAkatsuki is an Android library that handles [state restoration](http://developer.android.com/training/basics/activity-lifecycle/recreating.html) via annotations.\r\nThe library automatically generates source files through JSR269 to ensure almost<sup>1</sup> zero performance impact.\r\n\r\nTypical usage looks like:\r\n```java\r\npublic class MainActivity extends Activity {\r\n\r\n    @Retained String myString;\r\n    @Retained int myInt;\r\n    @Retained Account account; // Account implements Parcelable\r\n\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.activity_main);\r\n        Akatsuki.restore(this, savedInstanceState);\r\n        //everything restored!   \r\n    }\r\n\r\n    @Override\r\n    protected void onSaveInstanceState(Bundle outState) {\r\n        super.onSaveInstanceState(outState);\r\n        Akatsuki.save(this, outState);\r\n    }\r\n}\r\n```\r\nAnnotate the fields you want to persist, Akatsuki takes care of the rest.\r\n\r\nIf you are new to Android development, retaining fields are painful and error prone. You have to create string keys and then manually call the `set<Type>` and `get<Type>`of the `Bundle` object.\r\nTo demonstrate, here is the same Activity **without using Akatsuki:**\r\n\r\n```java\r\npublic class MainActivity extends Activity {\r\n\r\n    private static final String MY_STRING = \"myString\";\r\n    private static final String MY_INT = \"myInt\";\r\n    private static final String ACCOUNT = \"account\";\r\n\t\r\n\tString myString;\r\n\tint myInt;\r\n    Account account;\r\n\r\n\t@Override\r\n\tprotected void onCreate(Bundle savedInstanceState) {\r\n\t\tsuper.onCreate(savedInstanceState);\r\n\t\tsetContentView(R.layout.activity_main);\r\n\t\tmyString = savedInstanceState.getString(MY_STRING);\r\n\t\tmyInt = savedInstanceState.getInt(MY_INT);\r\n\t\taccount = savedInstanceState.getParcelable(ACCOUNT);\r\n\t}\r\n\r\n\t@Override\r\n\tprotected void onSaveInstanceState(Bundle outState) {\r\n\t\tsuper.onSaveInstanceState(outState);\r\n\t\toutState.putString(MY_STRING, myString);\r\n\t\toutState.putInt(MY_INT, myInt);\r\n\t\toutState.putParcelable(ACCOUNT, account);\r\n\t}\r\n}\r\n```\r\n<sup>1</sup>Reflection is used only once to locate the generated classes.\r\n\r\n----------\r\n\r\nAdvanced usage\r\n---------\r\nAkatsuki supports any kind of objects(Fragments, Services, and Views), not just Activity. As long as the persisting medium is a `Bundle`, the code generation will work.\r\n\r\nFor `View` states, Akatsuki provides several utility methods to make view state restoration possible. To demonstrate: \r\n\r\n```java\r\npublic static class MyView extends View {\r\n\r\n\t@Retained int myInt;\r\n\r\n\tpublic MyView(Context context) {\r\n\t\tsuper(context);\r\n\t}\r\n\r\n\t@Override\r\n\tprotected Parcelable onSaveInstanceState() {\r\n\t\treturn Akatsuki.save(this, super.onSaveInstanceState());\r\n\t}\r\n\r\n\t@Override\r\n\tprotected void onRestoreInstanceState(Parcelable state) {\r\n\t\tsuper.onRestoreInstanceState(Akatsuki.restore(this, state));\r\n\t}\r\n}\r\n```\r\nBecause `Bundle` is just a type safe container for `Parcel`, you can also use Akatsuki like so:\r\n\r\n```java\r\n// you can have some bean\r\nstatic class MyStuff{\r\n\t@Retained int foo;\r\n\t@Retained String bar;\r\n\t// your getters/setters etc\r\n}\r\n\r\n// serialize your bean into a Bundle\r\nMyStuff stuff = new MyStuff();\r\nBundle bundle = Akatsuki.serialize(stuff);\r\n\r\n\r\n// restore your bean from the Bundle\r\nMyStuff stuff = Akatsuki.deserialize(new MyStuff(), bundle);\r\n```\r\n\r\nFor debug purposes, `@Retain` has a method called `skip()`, when set to true, the field will not be retained. Adding the `transient` modifier also has the same effect.\r\n\r\n\r\n\r\nSupported types\r\n---------------\r\nAll data types supported by `Bundle` is supported by Akatsuki, that includes:\r\n```java\r\nIBinder\r\nboolean\r\nboolean[]\r\nBundle\r\nbyte\r\nbyte[]\r\nchar\r\nchar[]\r\nCharSequence\r\nCharSequence[]\r\nArrayList<CharSequence>\r\ndouble\r\ndouble[]\r\nfloat\r\nfloat[]\r\nIBinder\r\nint\r\nint[]\r\nArrayList<Integer>\r\nlong\r\nlong[]\r\nString\r\nParcelable\r\nParcelable[]\r\nArrayList<T>\r\nSerializable\r\nshort\r\nshort[]\r\nSize\r\nSizeF\r\nSparseArray<T>\r\nString\r\nString[]\r\nArrayList<String>\r\n```\r\n##Annotated types\r\nTypes annotated with `@Retained` will also be saved and restored **but not instantiated**.\r\nWhat this means is that you would have to do something like this:\r\n\r\n    \r\n```java\r\n@Retained MyType foo; // MyType has fields annotated with @Retained\r\n@Retained int bar;\r\n\r\n@Override\r\nprotected void onCreate(Bundle savedInstanceState) {\r\n    super.onCreate(savedInstanceState);\r\n    setContentView(R.layout.activity_main);\r\n    // manually instantiate your custom type\r\n\tfoo = new MyType(/* some arguments*/); \r\n\t// bar is a supported type so no need to instantiate\r\n    Akatsuki.restore(this, savedInstanceState); \r\n}\r\n```\r\nThis is because Akatsuki does not know how your custom type is created so you will have to instantiate it yourself **BEFORE** `Akatsuki.restore(Object, Bundle)` is called. \r\n##Generic parameters\r\nGeneric parameters are supported if and only if the type can be computed at compile time. This means that a type `<T>` must have known bounds.  \r\nThe following examples will work\r\n```java\r\n<T extends Parcelable> \r\n<T extends Serializable>\r\n<T extends Parcelable & Serializable> // intersection type\r\n```\r\nWhen a intersection type is found, a search for supported type is executed from left to right. If a supported type is found, that type will be used for serialization.\r\n\r\nInheritance\r\n-----------\r\n**Inheritance is fully supported**, annotated fields will continue to persist in subclasses.\r\n\r\n\r\n##Field hiding\r\n[Field hiding](https://docs.oracle.com/javase/tutorial/java/IandI/hidevariables.html) is supported through traversing the class hierarchy to avoid field name collisions.\r\nNOTE: The use of field hiding is discouraged as it makes code hard to follow.\r\n\r\n\r\n\r\nParceler support\r\n----------------\r\n\r\nAkatsuki supports [Parceler](https://github.com/johncarl81/parceler) annotated beans\r\nSimply add `@IncludeClasses(ParcelerSupport.class)` to any class in your project.(MainActivity or your custom Application class perhaps).\r\nAnd don't forget to import:\r\n```groovy\r\ncompile 'com.sora.util.akatsuki:akatsuki-parceler:${version}'\r\n```\r\n\r\n@TransformationTemplate\r\n----------------------\r\n`@TransformationTemplate` allows you to support arbitrary types. To understand how this works, here's the what the class `ParcelerSupport` actually looks like:\r\n\r\n```java\r\n@TransformationTemplate(\r\n\t\tsave = \"{{bundle}}.putParcelable(\\\"{{fieldName}}\\\", org.parceler.Parcels.wrap({{fieldName}}))\",\r\n\t\trestore = \"{{fieldName}} = org.parceler.Parcels.unwrap({{bundle}}.getParcelable(\\\"{{fieldName}}\\\"))\",\r\n\t\ttypes = {Parcel.class},\r\n\t\texecution = Execution.BEFORE)\r\npublic class ParcelerSupport {\r\n    // dummy class, any class in the project will work\r\n}\r\n```\r\nParceler annotated beans need `Parcels.wrap()` and `Parcels.unwrap()` before the object becomes usable. In the example above, we simply create a code template that includes the custom logic for wrapping and unwrapping Parceler objects.\r\nAkatsuki uses [mustache](https://mustache.github.io/) to convert the template into code that gets emitted into the generated source file. Everything is done in compile time so there will be no runtime cost. The `@TransformationTemplate` annotation has a retention of `RetentionPolicy.CLASS` so that it has no effect in runtime while other libraries using the annotation could still retain the template. For more information on how to write Transformation templates, the [javadoc]() contains examples and docs for all methods in the annotation.\r\n\r\nDue to a limitation of APT, if the template is located in another library, you have to include the class that is annotated with `@TransformationTemplate`  with `@IncludeClasses(TheClass.class)`, see the [Parceler support section ](#Parceler%20support) for more info.\r\n\r\nWhy another library?\r\n--------\r\nCurrently, we have [Icepick](https://github.com/frankiesardo/icepick) and possibly some other libraries that I'm not aware of. The main motivation for this library is due to the inflexibility of Icepick. Icepick does not support [Parceler](https://github.com/johncarl81/parceler) which is a deal breaker for me (there's a [discussion](https://github.com/frankiesardo/icepick/pull/20) on why that's the case). Incompatibility between Parceler and Icepick does not justify the creation of a another library, I could have forked Icepick and added the support myself and be happy. But no, I want to see how APT works so I did a [clean room implementation](https://en.wikipedia.org/wiki/Clean_room_design) of Icepick and added some other features.\r\n\r\nDownload\r\n--------\r\n```groovy\r\ncompile 'com.sora.util.akatsuki:akatsuki-api:${version}'\r\napt 'com.sora.util.akatsuki:akatsuki-compiler:${version}'\r\n```\r\n\r\nLicense\r\n-------\r\n\r\n    Copyright 2015 WEI CHEN LIN\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n       http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n\r\n\r\n\r\n\r\n","google":"UA-66117255-1","note":"Don't delete this file! It's used internally to help with page regeneration."}